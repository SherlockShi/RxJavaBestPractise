<resources>
    <string name="app_name">RxJavaBestPractise</string>

    <string name="activity_main_press_again_to_quit">再按一次退出程序</string>

    <string name="activity_description">描述</string>
    <string name="activity_graph">示意图</string>
    <string name="activity_sample_code">示例代码</string>
    <string name="activity_output">输出</string>

    <string name="activity_main_1_creating_observables">1. 创建操作</string>
    <string name="activity_main_2_transforming_observables">2. 变换操作</string>
    <string name="activity_main_3_filtering_observables">3. 过滤操作</string>
    <string name="activity_main_4_combining_observables">4. 组合操作</string>
    <string name="activity_main_5_error_handling_operators">5. 错误处理</string>
    <string name="activity_main_6_observable_utility_operators">6. 辅助操作</string>
    <string name="activity_main_7_conditional_and_boolean_operators">7. 条件和布尔操作</string>
    <string name="activity_main_8_mathematical_and_aggregate_operators">8. 算术和聚合操作</string>
    <string name="activity_main_9_backpressure_operators">9. 反压操作</string>
    <string name="activity_main_10_connectable_observable_operators">10. 连接操作</string>
    <string name="activity_main_11_operators_to_convert_observables">11. 转换操作</string>

    <!-- 1. 创建操作 start -->
    <string name="activity_category1_creating_observables_1_create">1.1 create</string>
    <string name="activity_category1_creating_observables_1_create_description">&#160;&#160;&#160;&#160;你可以使用 Create 操作符从头开始创建一个Observable，给这个操作符传递一个接受观察者作为参数的函数，编写这个函数让它的行为表现为一个Observable--恰当的调用观察者的onNext，onError和onCompleted方法。
        \n&#160;&#160;&#160;&#160;一个形式正确的有限Observable必须尝试调用观察者的onCompleted正好一次或者它的onError正好一次，而且此后不能再调用观察者的任何其它方法。
        \n&#160;&#160;&#160;&#160;RxJava将这个操作符实现为 create 方法。
        \n&#160;&#160;&#160;&#160;建议你在传递给create方法的函数中检查观察者的isUnsubscribed状态，以便在没有观察者的时候，让你的Observable停止发射数据或者做昂贵的运算。
        \n&#160;&#160;&#160;&#160; create 方法默认不在任何特定的调度器上执行。</string>

    <string name="activity_category1_creating_observables_2_defer">1.2 defer</string>
    <string name="activity_category1_creating_observables_2_defer_description">&#160;&#160;&#160;&#160;Defer操作符会一直等待直到有观察者订阅它，然后它使用Observable工厂方法生成一个Observable。它对每个观察者都这样做，因此尽管每个订阅者都以为自己订阅的是同一个Observable，事实上每个订阅者获取的是它们自己的单独的数据序列。
        \n&#160;&#160;&#160;&#160;在某些情况下，等待直到最后一分钟（就是知道订阅发生时）才生成Observable可以确保Observable包含最新的数据。
        \n&#160;&#160;&#160;&#160;RxJava将这个操作符实现为 defer 方法。这个操作符接受一个你选择的Observable工厂函数作为单个参数。这个函数没有参数，返回一个Observable。
        \n&#160;&#160;&#160;&#160;defer方法默认不在任何特定的调度器上执行。</string>

    <string name="activity_category1_creating_observables_2_defer_code_prefix_introductions">由于 defer 操作有以下几个特点：
        \n&#160;&#160;&#160;&#160;1) 订阅后才执行
        \n&#160;&#160;&#160;&#160;2) 每次都会重新创建新的Observable
        \n故本例从这两个特点进行说明。
        \n本例参考《Android RxJava使用介绍（二） RxJava的操作符》- 呼啸而过11。
        \n\n由运行结果可以看出：
        \n&#160;&#160;&#160;&#160;1) 订阅后才执行: just操作符是在创建Observable就进行了赋值操作，而defer是在订阅者订阅时才创建Observable，此时才进行真正的赋值操作，保证Observable的状态是最新的。
        \n&#160;&#160;&#160;&#160;2) 每次都会重新创建新的Observable(待验证)\n</string>

    <string name="activity_category1_creating_observables_31_empty">1.3.1 empty</string>
    <string name="activity_category1_creating_observables_32_never">1.3.2 never</string>
    <string name="activity_category1_creating_observables_33_throw">1.3.3 throw</string>
    <string name="activity_category1_creating_observables_31_empty_description">&#160;&#160;&#160;&#160;创建一个不发射任何数据但是正常终止的Observable。
        \n&#160;&#160;&#160;&#160;empty操作符一般会跟其它操作符配合使用。</string>
    <string name="activity_category1_creating_observables_32_never_description">&#160;&#160;&#160;&#160;创建一个不发射数据也不终止的Observable。</string>
    <string name="activity_category1_creating_observables_33_throw_description">&#160;&#160;&#160;&#160;创建一个不发射数据以一个错误终止的Observable。</string>

    <string name="activity_category1_creating_observables_4_from">1.4 from</string>
    <string name="activity_category1_creating_observables_4_from_description">&#160;&#160;&#160;&#160;将其它种类的对象和数据类型转换为Observable。
        \n&#160;&#160;&#160;&#160;当你使用Observable时，如果你要处理的数据都可以转换成展现为Observables，而不是需要混合使用Observables和其它类型的数据，会非常方便。这让你在数据流的整个生命周期中，可以使用一组统一的操作符来管理它们。
        \n&#160;&#160;&#160;&#160;例如，Iterable可以看成是同步的Observable；Future，可以看成是总是只发射单个数据的Observable。通过显式地将那些数据转换为Observables，你可以像使用Observable一样与它们交互。
        \n&#160;&#160;&#160;&#160;因此，大部分ReactiveX实现都提供了将语言特定的对象和数据结构转换为Observables的方法。
        \n&#160;&#160;&#160;&#160;在RxJava中，from操作符可以转换Future、Iterable和数组。对于Iterable和数组，产生的Observable会发射Iterable或数组的每一项数据。
        \n&#160;&#160;&#160;&#160;对于Future，它会发射Future.get()方法返回的单个数据。from方法有一个可接受两个可选参数的版本，分别指定超时时长和时间单位。如果过了指定的时长Future还没有返回一个值，这个Observable会发射错误通知并终止。
        \n&#160;&#160;&#160;&#160;from默认不在任何特定的调度器上执行。然而你可以将Scheduler作为可选的第二个参数传递给Observable，它会在那个调度器上管理这个Future。</string>

    <string name="activity_category1_creating_observables_5_interval">1.5 interval</string>
    <string name="activity_category1_creating_observables_5_interval_description">&#160;&#160;&#160;&#160;创建一个按固定时间间隔发射整数序列的Observable。
        \n&#160;&#160;&#160;&#160;Interval操作符返回一个Observable，它按固定的时间间隔发射一个无限递增的整数序列。
        \n&#160;&#160;&#160;&#160;还有一个版本的interval返回一个Observable，它在指定延迟之后先发射一个零值，然后再按照指定的时间间隔发射递增的数字。这个版本的interval在RxJava 1.0.0中叫做timer，但是那个方法已经不建议使用了，因为一个名叫interval的操作符有同样的功能。
        \n&#160;&#160;&#160;&#160;interval默认在computation调度器上执行。你也可以传递一个可选的Scheduler参数来指定调度器。
        \n&#160;&#160;&#160;&#160;需要注意的是这个对象是运行在computation Scheduler，所以如果需要在view中显示结果，要在主线程中订阅。</string>

    <string name="activity_category1_creating_observables_6_just">1.6 just</string>
    <string name="activity_category1_creating_observables_6_just_description">&#160;&#160;&#160;&#160;创建一个发射指定值的Observable。
        \n&#160;&#160;&#160;&#160;Just将单个数据转换为发射那个数据的Observable。
        \n&#160;&#160;&#160;&#160;Just类似于From，但是From会将数组或Iterable的数据取出然后逐个发射，而Just只是简单的原样发射，将数组或Iterable当做单个数据。
        \n&#160;&#160;&#160;&#160;注意：如果你传递null给Just，它会返回一个发射null值的Observable。不要误认为它会返回一个空Observable（完全不发射任何数据的Observable），如果需要空Observable你应该使用Empty操作符。
        \n&#160;&#160;&#160;&#160;RxJava将这个操作符实现为just函数，它接受一至九个参数，返回一个按参数列表顺序发射这些数据的Observable。</string>

    <string name="activity_category1_creating_observables_7_range">1.7 range</string>
    <string name="activity_category1_creating_observables_7_range_description">&#160;&#160;&#160;&#160;创建一个发射特定整数序列的Observable。
        \n&#160;&#160;&#160;&#160;Range操作符发射一个范围内的有序整数序列，你可以指定范围的起始和长度。
        \n&#160;&#160;&#160;&#160;RxJava将这个操作符实现为range函数，它接受两个参数，一个是范围的起始值，一个是范围的数据的数目。如果你将第二个参数设为0，将导致Observable不发射任何数据（如果设置为负数，会抛异常）。
        \n&#160;&#160;&#160;&#160;range默认不在任何特定的调度器上执行。有一个变体可以通过可选参数指定Scheduler。</string>

    <string name="activity_category1_creating_observables_8_repeat">1.8 repeat</string>
    <string name="activity_category1_creating_observables_8_repeat_description">&#160;&#160;&#160;&#160;创建一个发射特定数据重复多次的Observable。
        \n&#160;&#160;&#160;&#160;Repeat重复地发射数据。某些实现允许你重复的发射某个数据序列，还有一些允许你限制重复的次数。
        \n&#160;&#160;&#160;&#160;RxJava将这个操作符实现为repeat方法。它不是创建一个Observable，而是重复发射原始Observable的数据序列，这个序列或者是无限的，或者通过repeat(n)指定重复次数。
        \n&#160;&#160;&#160;&#160;repeat操作符默认在trampoline调度器上执行。有一个变体可以通过可选参数指定Scheduler。</string>

    <string name="activity_category1_creating_observables_9_start">1.9 start</string>
    <string name="activity_category1_creating_observables_9_start_description">&#160;&#160;&#160;&#160;返回一个Observable，它发射一个类似于函数声明的值。
        \n&#160;&#160;&#160;&#160;编程语言有很多种方法可以从运算结果中获取值，它们的名字一般叫functions, futures, actions, callables, runnables等等。在Start目录下的这组操作符可以让它们表现得像Observable，因此它们可以在Observables调用链中与其它Observable搭配使用。
        \n&#160;&#160;&#160;&#160;Start操作符的多种RxJava实现都属于可选的rxjava-async模块。
        \n&#160;&#160;&#160;&#160;rxjava-async模块包含start操作符，它接受一个函数作为参数，调用这个函数获取一个值，然后返回一个会发射这个值给后续观察者的Observable。
        \n&#160;&#160;&#160;&#160;注意：这个函数只会被执行一次，即使多个观察者订阅这个返回的Observable。</string>

    <string name="activity_category1_creating_observables_10_timer">1.10 timer</string>
    <string name="activity_category1_creating_observables_10_timer_description">&#160;&#160;&#160;&#160;创建一个Observable，它在一个给定的延迟后发射一个特殊的值。
        \n&#160;&#160;&#160;&#160;Timer操作符创建一个在给定的时间段之后返回一个特殊值的Observable。
        \n&#160;&#160;&#160;&#160;timer返回一个Observable，它在延迟一段给定的时间后发射一个简单的数字0。
        \n&#160;&#160;&#160;&#160;timer操作符默认在computation调度器上执行。有一个变体可以通过可选参数指定Scheduler。</string>
    <!-- 1. 创建操作 end -->

    <!-- 2. 变换操作 start -->
    <string name="activity_category2_transforming_observables_1_map">2.1 map</string>
    <string name="activity_category2_transforming_observables_1_map_description">&#160;&#160;&#160;&#160;对Observable发射的每一项数据应用一个函数，执行变换操作。
        \n&#160;&#160;&#160;&#160;Map操作符对原始Observable发射的每一项数据应用一个你选择的函数，然后返回一个发射这些结果的Observable。
        \n&#160;&#160;&#160;&#160;这个操作符默认不在任何特定的调度器上执行。</string>

    <string name="activity_category2_transforming_observables_2_flatmap">2.2 flatMap</string>
    <string name="activity_category2_transforming_observables_2_flatmap_description">&#160;&#160;&#160;&#160;FlatMap将一个发射数据的Observable变换为多个Observables，然后将它们发射的数据合并后放进一个单独的Observable。
        \n&#160;&#160;&#160;&#160;FlatMap操作符使用一个指定的函数对原始Observable发射的每一项数据执行变换操作，这个函数返回一个本身也发射数据的Observable，然后FlatMap合并这些Observables发射的数据，最后将合并后的结果当做它自己的数据序列发射。
        \n&#160;&#160;&#160;&#160;这个方法是很有用的，例如，当你有一个这样的Observable：它发射一个数据序列，这些数据本身包含Observable成员或者可以变换为Observable，因此你可以创建一个新的Observable发射这些次级Observable发射的数据的完整集合。
        \n&#160;&#160;&#160;&#160;注意：FlatMap对这些Observables发射的数据做的是合并(merge)操作，因此它们可能是交错的。
        \n&#160;&#160;&#160;&#160;在许多语言特定的实现中，还有一个操作符不会让变换后的Observables发射的数据交错，它按照严格的顺序发射这些数据，这个操作符通常被叫作ConcatMap或者类似的名字。
        \n&#160;&#160;&#160;&#160;注意：如果任何一个通过这个flatMap操作产生的单独的Observable调用onError异常终止了，这个Observable自身会立即调用onError并终止。</string>

    <string name="activity_category2_transforming_observables_3_scan">2.3 scan</string>
    <string name="activity_category2_transforming_observables_3_scan_description">&#160;&#160;&#160;&#160;连续地对数据序列的每一项应用一个函数，然后连续发射结果。
        \n&#160;&#160;&#160;&#160;Scan操作符对原始Observable发射的第一项数据应用一个函数，然后将那个函数的结果作为自己的第一项数据发射。它将函数的结果同第二项数据一起填充给这个函数来产生它自己的第二项数据。它持续进行这个过程来产生剩余的数据序列。这个操作符在某些情况下被叫做accumulator。</string>

    <string name="activity_category2_transforming_observables_4_groupby">2.4 groupBy</string>
    <string name="activity_category2_transforming_observables_4_groupby_description">&#160;&#160;&#160;&#160;将一个Observable分拆为一些Observables集合，它们中的每一个发射原始Observable的一个子序列。
        \n&#160;&#160;&#160;&#160;GroupBy操作符将原始Observable分拆为一些Observables集合，它们中的每一个发射原始Observable数据序列的一个子序列。哪个数据项由哪一个Observable发射是由一个函数判定的，这个函数给每一项指定一个Key，Key相同的数据会被同一个Observable发射。
        \n&#160;&#160;&#160;&#160;RxJava实现了groupBy操作符。它返回Observable的一个特殊子类GroupedObservable，实现了GroupedObservable接口的对象有一个额外的方法getKey，这个Key用于将数据分组到指定的Observable。
        \n&#160;&#160;&#160;&#160;有一个版本的groupBy允许你传递一个变换函数，这样它可以在发射结果GroupedObservable之前改变数据项。
        \n&#160;&#160;&#160;&#160;注意：groupBy将原始Observable分解为一个发射多个GroupedObservable的Observable，一旦有订阅，每个GroupedObservable就开始缓存数据。因此，如果你忽略这些GroupedObservable中的任何一个，这个缓存可能形成一个潜在的内存泄露。因此，如果你不想观察，也不要忽略GroupedObservable。你应该使用像take(0)这样会丢弃自己的缓存的操作符。
        \n&#160;&#160;&#160;&#160;如果你取消订阅一个GroupedObservable，那个Observable将会终止。如果之后原始的Observable又发射了一个与这个Observable的Key匹配的数据，groupBy将会为这个Key创建一个新的GroupedObservable。
        \n&#160;&#160;&#160;&#160;groupBy默认不在任何特定的调度器上执行。</string>

    <string name="activity_category2_transforming_observables_5_buffer">2.5 buffer</string>
    <string name="activity_category2_transforming_observables_5_buffer_description">&#160;&#160;&#160;&#160;定期收集Observable的数据放进一个数据包裹，然后发射这些数据包裹，而不是一次发射一个值。
        \n&#160;&#160;&#160;&#160;Buffer操作符将一个Observable变换为另一个，原来的Observable正常发射数据，变换产生的Observable发射这些数据的缓存集合。Buffer操作符在很多语言特定的实现中有很多种变体，它们在如何缓存这个问题上存在区别。
        \n&#160;&#160;&#160;&#160;注意：如果原来的Observable发射了一个onError通知，Buffer会立即传递这个通知，而不是首先发射缓存的数据，即使在这之前缓存中包含了原始Observable发射的数据。
        \n&#160;&#160;&#160;&#160;Window操作符与Buffer类似，但是它在发射之前把收集到的数据放进单独的Observable，而不是放进一个数据结构。</string>

    <string name="activity_category2_transforming_observables_6_window">2.6 window</string>
    <string name="activity_category2_transforming_observables_6_window_description">&#160;&#160;&#160;&#160;定期将来自原始Observable的数据分解为一个Observable窗口，发射这些窗口，而不是每次发射一项数据。
        \n&#160;&#160;&#160;&#160;Window和Buffer类似，但不是发射来自原始Observable的数据包，它发射的是Observables，这些Observables中的每一个都发射原始Observable数据的一个子集，最后发射一个onCompleted通知。
        \n&#160;&#160;&#160;&#160;和Buffer一样，Window有很多变体，每一种都以自己的方式将原始Observable分解为多个作为结果的Observable，每一个都包含一个映射原始数据的window。用Window操作符的术语描述就是，当一个窗口打开(when a window "opens")意味着一个新的Observable已经发射（产生）了，而且这个Observable开始发射来自原始Observable的数据；当一个窗口关闭(when a window "closes")意味着发射(产生)的Observable停止发射原始Observable的数据，并且发射终止通知onCompleted给它的观察者们。</string>
    <!-- 2. 变换操作 end -->

    <!-- 3. 过滤操作 start -->
    <string name="activity_category3_filtering_observables_1_filter">3.1 filter</string>
    <string name="activity_category3_filtering_observables_1_filter_description">&#160;&#160;&#160;&#160;只发射通过了谓词测试的数据项。
        \n&#160;&#160;&#160;&#160;Filter操作符使用你指定的一个谓词函数测试数据项，只有通过测试的数据才会被发射。
        \n&#160;&#160;&#160;&#160;filter默认不在任何特定的调度器上执行。</string>

    <string name="activity_category3_filtering_observables_2_take_last">3.2 takeLast</string>
    <string name="activity_category3_filtering_observables_2_take_last_description">&#160;&#160;&#160;&#160;发射Observable发射的最后N项数据。
        \n&#160;&#160;&#160;&#160;使用TakeLast操作符修改原始Observable，你可以只发射Observable发射的后N项数据，忽略前面的数据。
        \n&#160;&#160;&#160;&#160;使用takeLast操作符，你可以只发射原始Observable发射的后N项数据，忽略之前的数据。注意：这会延迟原始Observable发射的任何数据项，直到它全部完成。
        \n&#160;&#160;&#160;&#160;takeLast的这个变体默认不在任何特定的调度器上执行。</string>

    <string name="activity_category3_filtering_observables_3_last">3.3 last</string>
    <string name="activity_category3_filtering_observables_3_last_description">&#160;&#160;&#160;&#160;只发射最后一项（或者满足某个条件的最后一项）数据。
        \n&#160;&#160;&#160;&#160;如果你只对Observable发射的最后一项数据，或者满足某个条件的最后一项数据感兴趣，你可以使用Last操作符。
        \n&#160;&#160;&#160;&#160;在某些实现中，Last没有实现为一个返回Observable的过滤操作符，而是实现为一个在当时就发射原始Observable指定数据项的阻塞函数。在这些实现中，如果你想要的是一个过滤操作符，最好使用TakeLast(1)。
        \n&#160;&#160;&#160;&#160;在RxJava中的实现是last和lastOrDefault。
        \n&#160;&#160;&#160;&#160;可能容易混淆，BlockingObservable也有名叫last和lastOrDefault的操作符，它们会阻塞并返回值，不是立即返回一个Observable。
        \n&#160;&#160;&#160;&#160;只发射最后一项数据，使用没有参数的last操作符。</string>

    <string name="activity_category3_filtering_observables_4_skip">3.4 skip</string>
    <string name="activity_category3_filtering_observables_4_skip_description">&#160;&#160;&#160;&#160;抑制Observable发射的前N项数据。
        \n&#160;&#160;&#160;&#160;使用Skip操作符，你可以忽略Observable发射的前N项数据，只保留之后的数据。
        \n&#160;&#160;&#160;&#160;skip的这个变体默认不在任何特定的调度器上执行。</string>

    <string name="activity_category3_filtering_observables_5_skip_last">3.5 skipLast</string>
    <string name="activity_category3_filtering_observables_5_skip_last_description">&#160;&#160;&#160;&#160;抑制Observable发射的后N项数据。
        \n&#160;&#160;&#160;&#160;使用SkipLast操作符修改原始Observable，你可以忽略Observable发射的后N项数据，只保留前面的数据。
        \n&#160;&#160;&#160;&#160;使用SkipLast操作符，你可以忽略原始Observable发射的后N项数据，只保留之前的数据。注意：这个机制是这样实现的：延迟原始Observable发射的任何数据项，直到它发射了N项数据。
        \n&#160;&#160;&#160;&#160;skipLast的这个变体默认不在任何特定的调度器上执行。</string>

    <string name="activity_category3_filtering_observables_6_take">3.6 take</string>
    <string name="activity_category3_filtering_observables_6_take_description">&#160;&#160;&#160;&#160;只发射前面的N项数据。
        \n&#160;&#160;&#160;&#160;使用Take操作符让你可以修改Observable的行为，只返回前面的N项数据，然后发射完成通知，忽略剩余的数据。
        \n&#160;&#160;&#160;&#160;如果你对一个Observable使用take(n)（或它的同义词limit(n)）操作符，而那个Observable发射的数据少于N项，那么take操作生成的Observable不会抛异常或发射onError通知，在完成前它只会发射相同的少量数据。
        \n&#160;&#160;&#160;&#160;take(int)默认不任何特定的调度器上执行。</string>

    <string name="activity_category3_filtering_observables_7_first">3.7 first</string>
    <string name="activity_category3_filtering_observables_7_first_description">&#160;&#160;&#160;&#160;只发射第一项（或者满足某个条件的第一项）数据。
        \n&#160;&#160;&#160;&#160;如果你只对Observable发射的第一项数据，或者满足某个条件的第一项数据感兴趣，你可以使用First操作符。
        \n&#160;&#160;&#160;&#160;在某些实现中，First没有实现为一个返回Observable的过滤操作符，而是实现为一个在当时就发射原始Observable指定数据项的阻塞函数。在这些实现中，如果你想要的是一个过滤操作符，最好使用Take(1)或者ElementAt(0)。
        \n&#160;&#160;&#160;&#160;在一些实现中还有一个Single操作符。它的行为与First类似，但为了确保只发射单个值，它会等待原始Observable终止（否则，不是发射那个值，而是以一个错误通知终止）。你可以使用它从原始Observable获取第一项数据，而且也确保只发射一项数据。
        \n&#160;&#160;&#160;&#160;在RxJava中，这个操作符被实现为first，firstOrDefault和takeFirst。
        \n&#160;&#160;&#160;&#160;可能容易混淆，BlockingObservable也有名叫first和firstOrDefault的操作符，它们会阻塞并返回值，不是立即返回一个Observable。
        \n&#160;&#160;&#160;&#160;还有几个其它的操作符执行类似的功能。</string>

    <string name="activity_category3_filtering_observables_8_element_at">3.8 elementAt</string>
    <string name="activity_category3_filtering_observables_8_element_at_description">&#160;&#160;&#160;&#160;只发射第N项数据。
        \n&#160;&#160;&#160;&#160;ElementAt操作符获取原始Observable发射的数据序列指定索引位置的数据项，然后当做自己的唯一数据发射。
        \n&#160;&#160;&#160;&#160;RxJava将这个操作符实现为elementAt，给它传递一个基于0的索引值，它会发射原始Observable数据序列对应索引位置的值，如果你传递给elementAt的值为5，那么它会发射第六项的数据。
        \n&#160;&#160;&#160;&#160;如果你传递的是一个负数，或者原始Observable的数据项数小于index+1，将会抛出一个IndexOutOfBoundsException异常。</string>

    <string name="activity_category3_filtering_observables_9_sample">3.9 sample</string>
    <string name="activity_category3_filtering_observables_9_sample_description">&#160;&#160;&#160;&#160;定期发射Observable最近发射的数据项。
        \n&#160;&#160;&#160;&#160;Sample操作符定时查看一个Observable，然后发射自上次采样以来它最近发射的数据。
        \n&#160;&#160;&#160;&#160;在某些实现中，有一个ThrottleFirst操作符的功能类似，但不是发射采样期间的最近的数据，而是发射在那段时间内的第一项数据。
        \n&#160;&#160;&#160;&#160;RxJava将这个操作符实现为sample和throttleLast。
        \n&#160;&#160;&#160;&#160;注意：如果自上次采样以来，原始Observable没有发射任何数据，这个操作返回的Observable在那段时间内也不会发射任何数据。
        \n&#160;&#160;&#160;&#160;sample(别名throttleLast)的一个变体按照你参数中指定的时间间隔定时采样（TimeUnit指定时间单位）。
        \n&#160;&#160;&#160;&#160;sample的这个变体默认在computation调度器上执行，但是你可以使用第三个参数指定其它的调度器。</string>

    <string name="activity_category3_filtering_observables_10_debounce">3.10 debounce</string>
    <string name="activity_category3_filtering_observables_10_debounce_description">&#160;&#160;&#160;&#160;仅在过了一段指定的时间还没发射数据时才发射一个数据。
        \n&#160;&#160;&#160;&#160;Debounce操作符会过滤掉发射速率过快的数据项。
        \n&#160;&#160;&#160;&#160;RxJava将这个操作符实现为throttleWithTimeout和debounce。
        \n&#160;&#160;&#160;&#160;注意：这个操作符会会接着最后一项数据发射原始Observable的onCompleted通知，即使这个通知发生在你指定的时间窗口内（从最后一项数据的发射算起）。也就是说，onCompleted通知不会触发限流。</string>

    <string name="activity_category3_filtering_observables_11_distinct">3.11 distinct</string>
    <string name="activity_category3_filtering_observables_11_distinct_description">&#160;&#160;&#160;&#160;抑制（过滤掉）重复的数据项。
        \n&#160;&#160;&#160;&#160;Distinct的过滤规则是：只允许还没有发射过的数据项通过。
        \n&#160;&#160;&#160;&#160;在某些实现中，有一些变体允许你调整判定两个数据不同(distinct)的标准。还有一些实现只比较一项数据和它的直接前驱，因此只会从序列中过滤掉连续重复的数据。</string>

    <string name="activity_category3_filtering_observables_12_ignore_elements">3.12 ignoreElements</string>
    <string name="activity_category3_filtering_observables_12_ignore_elements_description">&#160;&#160;&#160;&#160;不发射任何数据，只发射Observable的终止通知。
        \n&#160;&#160;&#160;&#160;IgnoreElements操作符抑制原始Observable发射的所有数据，只允许它的终止通知（onError或onCompleted）通过。
        \n&#160;&#160;&#160;&#160;如果你不关心一个Observable发射的数据，但是希望在它完成时或遇到错误终止时收到通知，你可以对Observable使用ignoreElements操作符，它会确保永远不会调用观察者的onNext()方法。
        \n&#160;&#160;&#160;&#160;ignoreElements默认不在任何特定的调度器上执行。</string>
    <!-- 3. 过滤操作 end -->

    <!-- 4. 结合操作 start -->
    <string name="activity_category4_combining_observables_1_start_with">4.1 startWith</string>
    <string name="activity_category4_combining_observables_1_start_with_description">&#160;&#160;&#160;&#160;在数据序列的开头插入一条指定的项。
        \n&#160;&#160;&#160;&#160;如果你想要一个Observable在发射数据之前先发射一个指定的数据序列，可以使用StartWith操作符。（如果你想一个Observable发射的数据末尾追加一个数据序列可以使用Concat操作符。）</string>

    <string name="activity_category4_combining_observables_2_merge">4.2 merge</string>
    <string name="activity_category4_combining_observables_2_merge_description">&#160;&#160;&#160;&#160;合并多个Observables的发射物。
        \n&#160;&#160;&#160;&#160;使用Merge操作符你可以将多个Observables的输出合并，就好像它们是一个单个的Observable一样。
        \n&#160;&#160;&#160;&#160;Merge可能会让合并的Observables发射的数据交错（有一个类似的操作符Concat不会让数据交错，它会按顺序一个接着一个发射多个Observables的发射物）。
        \n&#160;&#160;&#160;&#160;正如图例上展示的，任何一个原始Observable的onError通知会被立即传递给观察者，而且会终止合并后的Observable。
        \n&#160;&#160;&#160;&#160;在很多ReactiveX实现中还有一个叫MergeDelayError的操作符，它的行为有一点不同，它会保留onError通知直到合并后的Observable所有的数据发射完成，在那时它才会把onError传递给观察者。
        \n&#160;&#160;&#160;&#160;除了传递多个Observable给merge，你还可以传递一个Observable列表List，数组，甚至是一个发射Observable序列的Observable，merge将合并它们的输出作为单个Observable的输出。
        \n&#160;&#160;&#160;&#160;如果你传递一个发射Observables序列的Observable，你可以指定merge应该同时订阅的Observable的最大数量。一旦达到订阅数的限制，它将不再订阅原始Observable发射的任何其它Observable，直到某个已经订阅的Observable发射了onCompleted通知。
        \n&#160;&#160;&#160;&#160;merge是静态方法，mergeWith是对象方法，举个例子，Observable.merge(odds,evens)等价于odds.mergeWith(evens)。
        \n&#160;&#160;&#160;&#160;如果传递给merge的任何一个的Observable发射了onError通知终止了，merge操作符生成的Observable也会立即以onError通知终止。如果你想让它继续发射数据，在最后才报告错误，可以使用mergeDelayError。</string>

    <string name="activity_category4_combining_observables_3_zip">4.3 zip</string>
    <string name="activity_category4_combining_observables_3_zip_description">&#160;&#160;&#160;&#160;通过一个函数将多个Observables的发射物结合到一起，基于这个函数的结果为每个结合体发射单个数据项。
        \n&#160;&#160;&#160;&#160;Zip操作符返回一个Obversable，它使用这个函数按顺序结合两个或多个Observables发射的数据项，然后它发射这个函数返回的结果。它按照严格的顺序应用这个函数。它只发射与发射数据项最少的那个Observable一样多的数据。
        \n&#160;&#160;&#160;&#160;zip的最后一个参数接受每个Observable发射的一项数据，返回被压缩后的数据，它可以接受一到九个参数：一个Observable序列，或者一些发射Observable的Observables。</string>

    <string name="activity_category4_combining_observables_4_and_then_when">4.4 and/then/when</string>
    <string name="activity_category4_combining_observables_4_and_then_when_description">&#160;&#160;&#160;&#160;使用Pattern和Plan作为中介，将两个或多个Observable发射的数据集合并到一起。
        \n&#160;&#160;&#160;&#160;And/Then/When操作符组合的行为类似于zip，但是它们使用一个中间数据结构。接受两个或多个Observable，一次一个将它们的发射物合并到Pattern对象，然后操作那个Pattern对象，变换为一个Plan。随后将这些Plan变换为Observable的发射物。
        \n&#160;&#160;&#160;&#160;它们属于rxjava-joins模块，不是核心RxJava包的一部分。</string>

    <string name="activity_category4_combining_observables_5_combine_latest">4.5 combineLatest</string>
    <string name="activity_category4_combining_observables_5_combine_latest_description">&#160;&#160;&#160;&#160;当两个Observables中的任何一个发射了数据时，使用一个函数结合每个Observable发射的最近数据项，并且基于这个函数的结果发射数据。
        \n&#160;&#160;&#160;&#160;CombineLatest操作符行为类似于zip，但是只有当原始的Observable中的每一个都发射了一条数据时zip才发射数据。CombineLatest则在原始的Observable中任意一个发射了数据时发射一条数据。当原始Observables的任何一个发射了一条数据时，CombineLatest使用一个函数结合它们最近发射的数据，然后发射这个函数的返回值。
        \n&#160;&#160;&#160;&#160;RxJava将这个操作符实现为combineLatest，它接受二到九个Observable作为参数，或者单个Observables列表作为参数。它默认不在任何特定的调度器上执行。</string>

    <string name="activity_category4_combining_observables_6_join">4.6 join</string>
    <string name="activity_category4_combining_observables_6_join_description">&#160;&#160;&#160;&#160;任何时候，只要在另一个Observable发射的数据定义的时间窗口内，这个Observable发射了一条数据，就结合两个Observable发射的数据。
        \n&#160;&#160;&#160;&#160;Join操作符结合两个Observable发射的数据，基于时间窗口（你定义的针对每条数据特定的原则）选择待集合的数据项。你将这些时间窗口实现为一些Observables，它们的生命周期从任何一条Observable发射的每一条数据开始。当这个定义时间窗口的Observable发射了一条数据或者完成时，与这条数据关联的窗口也会关闭。只要这条数据的窗口是打开的，它将继续结合其它Observable发射的任何数据项。你定义一个用于结合数据的函数。
        \n&#160;&#160;&#160;&#160;join默认不在任何特定的调度器上执行。</string>

    <string name="activity_category4_combining_observables_7_switch">4.7 switch</string>
    <string name="activity_category4_combining_observables_7_switch_description">&#160;&#160;&#160;&#160;将一个发射多个Observables的Observable转换成另一个单独的Observable，后者发射那些Observables最近发射的数据项。
        \n&#160;&#160;&#160;&#160;Switch订阅一个发射多个Observables的Observable。它每次观察那些Observables中的一个，Switch返回的这个Observable取消订阅前一个发射数据的Observable，开始发射最近的Observable发射的数据。注意：当原始Observable发射了一个新的Observable时（不是这个新的Observable发射了一条数据时），它将取消订阅之前的那个Observable。这意味着，在后来那个Observable产生之后到它开始发射数据之前的这段时间里，前一个Observable发射的数据将被丢弃（就像图例上的那个黄色圆圈一样）。
        \n&#160;&#160;&#160;&#160;Java将这个操作符实现为switchOnNext。它默认不在任何特定的调度器上执行。</string>
    <!-- 4. 结合操作 end -->
</resources>
