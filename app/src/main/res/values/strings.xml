<resources>
    <string name="app_name">RxJavaBestPractise</string>

    <string name="activity_main_press_again_to_quit">再按一次退出程序</string>

    <string name="activity_description">描述</string>
    <string name="activity_graph">示意图</string>
    <string name="activity_sample_code">示例代码</string>
    <string name="activity_output">输出</string>

    <string name="activity_main_1_creating_observables">1. 创建操作</string>
    <string name="activity_main_2_transforming_observables">2. 变换操作</string>
    <string name="activity_main_3_filtering_observables">3. 过滤操作</string>
    <string name="activity_main_4_combining_observables">4. 组合操作</string>
    <string name="activity_main_5_error_handling_operators">5. 错误处理</string>
    <string name="activity_main_6_observable_utility_operators">6. 辅助操作</string>
    <string name="activity_main_7_conditional_and_boolean_operators">7. 条件和布尔操作</string>
    <string name="activity_main_8_mathematical_and_aggregate_operators">8. 算术和聚合操作</string>
    <string name="activity_main_9_backpressure_operators">9. </string>
    <string name="activity_main_10_connectable_observable_operators">10. 连接操作</string>
    <string name="activity_main_11_operators_to_convert_observables">11. 转换操作</string>

    <!-- 1. 创建操作 start -->
    <string name="activity_category1_creating_observables_1_create">1.1 create</string>
    <string name="activity_category1_creating_observables_1_create_description">&#160;&#160;&#160;&#160;你可以使用 Create 操作符从头开始创建一个Observable，给这个操作符传递一个接受观察者作为参数的函数，编写这个函数让它的行为表现为一个Observable--恰当的调用观察者的onNext，onError和onCompleted方法。
        \n&#160;&#160;&#160;&#160;一个形式正确的有限Observable必须尝试调用观察者的onCompleted正好一次或者它的onError正好一次，而且此后不能再调用观察者的任何其它方法。
        \n&#160;&#160;&#160;&#160;RxJava将这个操作符实现为 create 方法。
        \n&#160;&#160;&#160;&#160;建议你在传递给create方法的函数中检查观察者的isUnsubscribed状态，以便在没有观察者的时候，让你的Observable停止发射数据或者做昂贵的运算。
        \n&#160;&#160;&#160;&#160; create 方法默认不在任何特定的调度器上执行。</string>

    <string name="activity_category1_creating_observables_2_defer">1.2 defer</string>
    <string name="activity_category1_creating_observables_2_defer_description">&#160;&#160;&#160;&#160;Defer操作符会一直等待直到有观察者订阅它，然后它使用Observable工厂方法生成一个Observable。它对每个观察者都这样做，因此尽管每个订阅者都以为自己订阅的是同一个Observable，事实上每个订阅者获取的是它们自己的单独的数据序列。
        \n&#160;&#160;&#160;&#160;在某些情况下，等待直到最后一分钟（就是知道订阅发生时）才生成Observable可以确保Observable包含最新的数据。
        \n&#160;&#160;&#160;&#160;RxJava将这个操作符实现为 defer 方法。这个操作符接受一个你选择的Observable工厂函数作为单个参数。这个函数没有参数，返回一个Observable。
        \n&#160;&#160;&#160;&#160;defer方法默认不在任何特定的调度器上执行。</string>

    <string name="activity_category1_creating_observables_2_defer_code_prefix_introductions">由于 defer 操作有以下几个特点：
        \n&#160;&#160;&#160;&#160;1) 订阅后才执行
        \n&#160;&#160;&#160;&#160;2) 每次都会重新创建新的Observable
        \n故本例从这两个特点进行说明。
        \n本例参考《Android RxJava使用介绍（二） RxJava的操作符》- 呼啸而过11。
        \n\n由运行结果可以看出：
        \n&#160;&#160;&#160;&#160;1) 订阅后才执行: just操作符是在创建Observable就进行了赋值操作，而defer是在订阅者订阅时才创建Observable，此时才进行真正的赋值操作，保证Observable的状态是最新的。
        \n&#160;&#160;&#160;&#160;2) 每次都会重新创建新的Observable(待验证)\n</string>

    <string name="activity_category1_creating_observables_31_empty">1.3.1 empty</string>
    <string name="activity_category1_creating_observables_32_never">1.3.2 never</string>
    <string name="activity_category1_creating_observables_33_throw">1.3.3 throw</string>
    <string name="activity_category1_creating_observables_31_empty_description">&#160;&#160;&#160;&#160;创建一个不发射任何数据但是正常终止的Observable。
        \n&#160;&#160;&#160;&#160;empty操作符一般会跟其它操作符配合使用。</string>
    <string name="activity_category1_creating_observables_32_never_description">&#160;&#160;&#160;&#160;创建一个不发射数据也不终止的Observable。</string>
    <string name="activity_category1_creating_observables_33_throw_description">&#160;&#160;&#160;&#160;创建一个不发射数据以一个错误终止的Observable。</string>

    <string name="activity_category1_creating_observables_4_from">1.4 from</string>
    <string name="activity_category1_creating_observables_4_from_description">&#160;&#160;&#160;&#160;将其它种类的对象和数据类型转换为Observable。
        \n&#160;&#160;&#160;&#160;当你使用Observable时，如果你要处理的数据都可以转换成展现为Observables，而不是需要混合使用Observables和其它类型的数据，会非常方便。这让你在数据流的整个生命周期中，可以使用一组统一的操作符来管理它们。
        \n&#160;&#160;&#160;&#160;例如，Iterable可以看成是同步的Observable；Future，可以看成是总是只发射单个数据的Observable。通过显式地将那些数据转换为Observables，你可以像使用Observable一样与它们交互。
        \n&#160;&#160;&#160;&#160;因此，大部分ReactiveX实现都提供了将语言特定的对象和数据结构转换为Observables的方法。
        \n&#160;&#160;&#160;&#160;在RxJava中，from操作符可以转换Future、Iterable和数组。对于Iterable和数组，产生的Observable会发射Iterable或数组的每一项数据。
        \n&#160;&#160;&#160;&#160;对于Future，它会发射Future.get()方法返回的单个数据。from方法有一个可接受两个可选参数的版本，分别指定超时时长和时间单位。如果过了指定的时长Future还没有返回一个值，这个Observable会发射错误通知并终止。
        \n&#160;&#160;&#160;&#160;from默认不在任何特定的调度器上执行。然而你可以将Scheduler作为可选的第二个参数传递给Observable，它会在那个调度器上管理这个Future。</string>

    <string name="activity_category1_creating_observables_5_interval">1.5 interval</string>
    <string name="activity_category1_creating_observables_5_interval_description">&#160;&#160;&#160;&#160;创建一个按固定时间间隔发射整数序列的Observable。
        \n&#160;&#160;&#160;&#160;Interval操作符返回一个Observable，它按固定的时间间隔发射一个无限递增的整数序列。
        \n&#160;&#160;&#160;&#160;还有一个版本的interval返回一个Observable，它在指定延迟之后先发射一个零值，然后再按照指定的时间间隔发射递增的数字。这个版本的interval在RxJava 1.0.0中叫做timer，但是那个方法已经不建议使用了，因为一个名叫interval的操作符有同样的功能。
        \n&#160;&#160;&#160;&#160;interval默认在computation调度器上执行。你也可以传递一个可选的Scheduler参数来指定调度器。
        \n&#160;&#160;&#160;&#160;需要注意的是这个对象是运行在computation Scheduler，所以如果需要在view中显示结果，要在主线程中订阅。</string>

    <string name="activity_category1_creating_observables_6_just">1.6 just</string>
    <string name="activity_category1_creating_observables_6_just_description">&#160;&#160;&#160;&#160;创建一个发射指定值的Observable。
        \n&#160;&#160;&#160;&#160;Just将单个数据转换为发射那个数据的Observable。
        \n&#160;&#160;&#160;&#160;Just类似于From，但是From会将数组或Iterable的数据取出然后逐个发射，而Just只是简单的原样发射，将数组或Iterable当做单个数据。
        \n&#160;&#160;&#160;&#160;注意：如果你传递null给Just，它会返回一个发射null值的Observable。不要误认为它会返回一个空Observable（完全不发射任何数据的Observable），如果需要空Observable你应该使用Empty操作符。
        \n&#160;&#160;&#160;&#160;RxJava将这个操作符实现为just函数，它接受一至九个参数，返回一个按参数列表顺序发射这些数据的Observable。</string>

    <string name="activity_category1_creating_observables_7_range">1.7 range</string>
    <string name="activity_category1_creating_observables_7_range_description">&#160;&#160;&#160;&#160;创建一个发射特定整数序列的Observable。
        \n&#160;&#160;&#160;&#160;Range操作符发射一个范围内的有序整数序列，你可以指定范围的起始和长度。
        \n&#160;&#160;&#160;&#160;RxJava将这个操作符实现为range函数，它接受两个参数，一个是范围的起始值，一个是范围的数据的数目。如果你将第二个参数设为0，将导致Observable不发射任何数据（如果设置为负数，会抛异常）。
        \n&#160;&#160;&#160;&#160;range默认不在任何特定的调度器上执行。有一个变体可以通过可选参数指定Scheduler。</string>

    <string name="activity_category1_creating_observables_8_repeat">1.8 repeat</string>
    <string name="activity_category1_creating_observables_8_repeat_description">&#160;&#160;&#160;&#160;创建一个发射特定数据重复多次的Observable。
        \n&#160;&#160;&#160;&#160;Repeat重复地发射数据。某些实现允许你重复的发射某个数据序列，还有一些允许你限制重复的次数。
        \n&#160;&#160;&#160;&#160;RxJava将这个操作符实现为repeat方法。它不是创建一个Observable，而是重复发射原始Observable的数据序列，这个序列或者是无限的，或者通过repeat(n)指定重复次数。
        \n&#160;&#160;&#160;&#160;repeat操作符默认在trampoline调度器上执行。有一个变体可以通过可选参数指定Scheduler。</string>

    <string name="activity_category1_creating_observables_9_start">1.9 start</string>
    <string name="activity_category1_creating_observables_9_start_description">&#160;&#160;&#160;&#160;返回一个Observable，它发射一个类似于函数声明的值。
        \n&#160;&#160;&#160;&#160;编程语言有很多种方法可以从运算结果中获取值，它们的名字一般叫functions, futures, actions, callables, runnables等等。在Start目录下的这组操作符可以让它们表现得像Observable，因此它们可以在Observables调用链中与其它Observable搭配使用。
        \n&#160;&#160;&#160;&#160;Start操作符的多种RxJava实现都属于可选的rxjava-async模块。
        \n&#160;&#160;&#160;&#160;rxjava-async模块包含start操作符，它接受一个函数作为参数，调用这个函数获取一个值，然后返回一个会发射这个值给后续观察者的Observable。
        \n&#160;&#160;&#160;&#160;注意：这个函数只会被执行一次，即使多个观察者订阅这个返回的Observable。</string>

    <string name="activity_category1_creating_observables_10_timer">1.10 timer</string>
    <string name="activity_category1_creating_observables_10_timer_description">&#160;&#160;&#160;&#160;创建一个Observable，它在一个给定的延迟后发射一个特殊的值。
        \n&#160;&#160;&#160;&#160;Timer操作符创建一个在给定的时间段之后返回一个特殊值的Observable。
        \n&#160;&#160;&#160;&#160;timer返回一个Observable，它在延迟一段给定的时间后发射一个简单的数字0。
        \n&#160;&#160;&#160;&#160;timer操作符默认在computation调度器上执行。有一个变体可以通过可选参数指定Scheduler。</string>
    <!-- 1. 创建操作 end -->

    <!-- 2. 变换操作 start -->
    <string name="activity_category2_transforming_observables_1_map">2.1 map</string>
    <string name="activity_category2_transforming_observables_1_map_description">&#160;&#160;&#160;&#160;对Observable发射的每一项数据应用一个函数，执行变换操作。
        \n&#160;&#160;&#160;&#160;Map操作符对原始Observable发射的每一项数据应用一个你选择的函数，然后返回一个发射这些结果的Observable。
        \n&#160;&#160;&#160;&#160;这个操作符默认不在任何特定的调度器上执行。</string>

    <string name="activity_category2_transforming_observables_2_flatmap">2.2 flatMap</string>
    <string name="activity_category2_transforming_observables_2_flatmap_description">&#160;&#160;&#160;&#160;FlatMap将一个发射数据的Observable变换为多个Observables，然后将它们发射的数据合并后放进一个单独的Observable。
        \n&#160;&#160;&#160;&#160;FlatMap操作符使用一个指定的函数对原始Observable发射的每一项数据执行变换操作，这个函数返回一个本身也发射数据的Observable，然后FlatMap合并这些Observables发射的数据，最后将合并后的结果当做它自己的数据序列发射。
        \n&#160;&#160;&#160;&#160;这个方法是很有用的，例如，当你有一个这样的Observable：它发射一个数据序列，这些数据本身包含Observable成员或者可以变换为Observable，因此你可以创建一个新的Observable发射这些次级Observable发射的数据的完整集合。
        \n&#160;&#160;&#160;&#160;注意：FlatMap对这些Observables发射的数据做的是合并(merge)操作，因此它们可能是交错的。
        \n&#160;&#160;&#160;&#160;在许多语言特定的实现中，还有一个操作符不会让变换后的Observables发射的数据交错，它按照严格的顺序发射这些数据，这个操作符通常被叫作ConcatMap或者类似的名字。
        \n&#160;&#160;&#160;&#160;注意：如果任何一个通过这个flatMap操作产生的单独的Observable调用onError异常终止了，这个Observable自身会立即调用onError并终止。</string>

    <string name="activity_category2_transforming_observables_3_scan">2.3 scan</string>
    <string name="activity_category2_transforming_observables_3_scan_description">&#160;&#160;&#160;&#160;连续地对数据序列的每一项应用一个函数，然后连续发射结果。
        \n&#160;&#160;&#160;&#160;Scan操作符对原始Observable发射的第一项数据应用一个函数，然后将那个函数的结果作为自己的第一项数据发射。它将函数的结果同第二项数据一起填充给这个函数来产生它自己的第二项数据。它持续进行这个过程来产生剩余的数据序列。这个操作符在某些情况下被叫做accumulator。</string>

    <string name="activity_category2_transforming_observables_4_groupby">2.4 groupBy</string>
    <string name="activity_category2_transforming_observables_4_groupby_description">&#160;&#160;&#160;&#160;将一个Observable分拆为一些Observables集合，它们中的每一个发射原始Observable的一个子序列。
        \n&#160;&#160;&#160;&#160;GroupBy操作符将原始Observable分拆为一些Observables集合，它们中的每一个发射原始Observable数据序列的一个子序列。哪个数据项由哪一个Observable发射是由一个函数判定的，这个函数给每一项指定一个Key，Key相同的数据会被同一个Observable发射。
        \n&#160;&#160;&#160;&#160;RxJava实现了groupBy操作符。它返回Observable的一个特殊子类GroupedObservable，实现了GroupedObservable接口的对象有一个额外的方法getKey，这个Key用于将数据分组到指定的Observable。
        \n&#160;&#160;&#160;&#160;有一个版本的groupBy允许你传递一个变换函数，这样它可以在发射结果GroupedObservable之前改变数据项。
        \n&#160;&#160;&#160;&#160;注意：groupBy将原始Observable分解为一个发射多个GroupedObservable的Observable，一旦有订阅，每个GroupedObservable就开始缓存数据。因此，如果你忽略这些GroupedObservable中的任何一个，这个缓存可能形成一个潜在的内存泄露。因此，如果你不想观察，也不要忽略GroupedObservable。你应该使用像take(0)这样会丢弃自己的缓存的操作符。
        \n&#160;&#160;&#160;&#160;如果你取消订阅一个GroupedObservable，那个Observable将会终止。如果之后原始的Observable又发射了一个与这个Observable的Key匹配的数据，groupBy将会为这个Key创建一个新的GroupedObservable。
        \n&#160;&#160;&#160;&#160;groupBy默认不在任何特定的调度器上执行。</string>

    <string name="activity_category2_transforming_observables_5_buffer">2.5 buffer</string>
    <string name="activity_category2_transforming_observables_5_buffer_description">&#160;&#160;&#160;&#160;定期收集Observable的数据放进一个数据包裹，然后发射这些数据包裹，而不是一次发射一个值。
        \n&#160;&#160;&#160;&#160;Buffer操作符将一个Observable变换为另一个，原来的Observable正常发射数据，变换产生的Observable发射这些数据的缓存集合。Buffer操作符在很多语言特定的实现中有很多种变体，它们在如何缓存这个问题上存在区别。
        \n&#160;&#160;&#160;&#160;注意：如果原来的Observable发射了一个onError通知，Buffer会立即传递这个通知，而不是首先发射缓存的数据，即使在这之前缓存中包含了原始Observable发射的数据。
        \n&#160;&#160;&#160;&#160;Window操作符与Buffer类似，但是它在发射之前把收集到的数据放进单独的Observable，而不是放进一个数据结构。</string>

    <string name="activity_category2_transforming_observables_6_window">2.6 window</string>
    <string name="activity_category2_transforming_observables_6_window_description">&#160;&#160;&#160;&#160;定期将来自原始Observable的数据分解为一个Observable窗口，发射这些窗口，而不是每次发射一项数据。
        \n&#160;&#160;&#160;&#160;Window和Buffer类似，但不是发射来自原始Observable的数据包，它发射的是Observables，这些Observables中的每一个都发射原始Observable数据的一个子集，最后发射一个onCompleted通知。
        \n&#160;&#160;&#160;&#160;和Buffer一样，Window有很多变体，每一种都以自己的方式将原始Observable分解为多个作为结果的Observable，每一个都包含一个映射原始数据的window。用Window操作符的术语描述就是，当一个窗口打开(when a window "opens")意味着一个新的Observable已经发射（产生）了，而且这个Observable开始发射来自原始Observable的数据；当一个窗口关闭(when a window "closes")意味着发射(产生)的Observable停止发射原始Observable的数据，并且发射终止通知onCompleted给它的观察者们。</string>
    <!-- 2. 变换操作 end -->
</resources>
